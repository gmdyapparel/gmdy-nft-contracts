import{flowConfig as e}from"@onflow/fcl-config";import{config as n}from"@onflow/config";import t from"fs";import a from"path";import*as r from"@onflow/fcl";import{send as s,build as o,getBlock as c,decode as i}from"@onflow/fcl";import{resolveArguments as l,getEnvironment as g,reportMissingImports as u,replaceImportAddresses as d,reportMissing as p,sendTransaction as f,extractContractParameters as m,generateSchema as w,splitArgs as h,deployContract as M,executeScript as A}from"flow-cadut";import{ec as y}from"elliptic";import{SHA3 as b}from"sha3";import*as k from"rlp";const x=(e,n,t)=>{if("string"==typeof n)return x(e,n.split("/"),t);if(!n.length)return e;try{const[a,...r]=n;return x(e[a],r,t)}catch(e){return t}},S=(t,a,r,s)=>{let o=x(e(),r,s);o||(o=s),n().put(t,o)},F=async e=>n().get(e),T=async(e,t={})=>{const{port:a=8080}=t,{pkey:r="48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902"}=t;S("PRIVATE_KEY",process,"accounts/emulator-account/key",r),S("SERVICE_ADDRESS",process,"accounts/emulator-account/address","f8d6e0586b0a20c7"),S("BASE_PATH",process,"testing/paths",e),n().put("accessNode.api",`http://localhost:${a}`)};function v(){return v=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},v.apply(this,arguments)}const P=e=>null==e?null:e.replace(/^0x/,""),E=e=>null==e?null:"0x"+P(e),B=new y("p256"),C=(e,n)=>{const t=B.keyFromPrivate(Buffer.from(e,"hex")).sign((e=>{const n=new b(256);return n.update(Buffer.from(e,"hex")),n.digest()})(n)),a=t.r.toArrayLike(Buffer,"be",32),r=t.s.toArrayLike(Buffer,"be",32);return Buffer.concat([a,r]).toString("hex")},R=(e,t=0)=>async(a={})=>{const s=await n().get("SERVICE_ADDRESS"),o=await n().get("PRIVATE_KEY");return v({},a,{tempId:`${e=P(e||s)}-${t}`,addr:r.sansPrefix(e),keyId:t,signingFunction:async n=>({keyId:t,addr:E(e),signature:C(o,n.message)})})},I=e=>"object"==typeof e&&null!==e,O=e=>async n=>{let t,a,r,s,o,c,i,l;if(I(n[0])){const[e]=n,{name:l,code:g,args:u,signers:d,transformers:p,limit:f,service:m=!1}=e;if(o=m,!l&&!g)throw Error("Both `name` and `code` are missing. Provide either of them");a=l,t=g,r=d,s=u,c=p||[],i=f}else"script"===e?[a,s,i,c]=n:[a,r,s,i,c]=n;if(i=i||999,a){const n="script"===e?Ee:Pe;t=await n({name:a})}l=o?xe:await ke(t);const g=await de(),u=v({},xe,l,{FlowManager:g});t=be(t,u);for(const e in c){const n=c[e];t=await n(t)}return{code:t,signers:r,args:s,limit:i}},U=async(...e)=>{try{const n=O("tx"),{code:t,args:a,signers:s,limit:o}=await n(e),c=R(),i=[r.transaction(t),r.payer(c),r.proposer(c),r.limit(o)];if(s){const e=s.map(e=>R(e));i.push(r.authorizations(e))}else i.push(r.authorizations([c]));if(a){const e=await l(a,t);i.push(r.args(e))}const g=await r.send(i);return[await r.tx(g).onceExecuted(),null]}catch(e){return[null,e]}},$=async(...e)=>{try{const n=O("script"),{code:t,args:a,limit:s}=await n(e),o=[r.script(t),r.limit(s)];if(a){const e=await l(a,t);o.push(r.args(e))}const c=await r.send(o);return[await r.decode(c),null]}catch(e){return[null,e]}},_="\n  import FlowManager from 0x01\n\ntransaction (_ name: String, pubKey: String, manager: Address) {\n    prepare( admin: AuthAccount) {\n        let newAccount = AuthAccount(payer:admin)\n        newAccount.addPublicKey(pubKey.decodeHex())\n\n        let linkPath = FlowManager.accountManagerPath\n        let accountManager = getAccount(manager)\n                            .getCapability(linkPath)!\n                            .borrow<&FlowManager.Mapper>()!\n        \n        // Create a record in account database\n        let address = newAccount.address\n        accountManager.setAddress(name, address: address)\n    }\n}\n\n",D=async(e={})=>{const n=v({},await g(),e);return u(_,n,"createAccount =>"),d(_,n)},L="\nimport FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        acct.contracts.add(\n           name: name,\n           code: decoded,\n           ##ARGS-LIST##\n        )\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",H=async(e={})=>{const n=v({},await g(),e);return u(L,n,"deployContract =>"),d(L,n)},G='\n  transaction ( code: String ) {\n    prepare( admin: AuthAccount) {\n        admin.contracts.add(\n           name: "FlowManager",\n           code: code.decodeHex(),\n        )\n   }\n  }\n',K=async(e={})=>{const n=v({},await g(),e);return u(G,n,"initManager =>"),d(G,n)},V='\n  import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic("Signer is not the token admin")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic("Unable to borrow receiver reference")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n',z=async(e={})=>{const n=v({},await g(),e);return u(V,n,"mintTokens =>"),d(V,n)},N="\n  import FlowManager from 0x01\n\ntransaction(name: String, address: Address) {\n    prepare(signer: AuthAccount){\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = signer\n                                .getCapability(linkPath)!\n                                .borrow<&FlowManager.Mapper>()!\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",Y=async(e={})=>{const n=v({},await g(),e);return u(N,n,"registerContract =>"),d(N,n)},j="\n  transaction{\n    prepare(acct: AuthAccount){\n        log(acct.address)\n    }\n}\n",W=async(e={})=>{const n=v({},await g(),e);return u(j,n,"scratch =>"),d(j,n)},q="\n  import FlowManager from 0x01\n\ntransaction(offset: UInt64){\n    prepare(signer:AuthAccount){\n        FlowManager.setBlockOffset(offset)\n    }\n}\n\n",J=async(e={})=>{const n=v({},await g(),e);return u(q,n,"setBlockOffset =>"),d(q,n)},Q="\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",X=async(e={})=>{const n=v({},await g(),e);return u(Q,n,"updateContract =>"),d(Q,n)};var Z={createAccountTemplate:D,createAccount:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await D(n);return p("arguments",t.length,3,"createAccount =>"),p("signers",a.length,1,"createAccount =>"),f(v({code:r},e))},deployContractTemplate:H,deployContract:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await H(n);return p("arguments",t.length,3,"deployContract =>"),p("signers",a.length,1,"deployContract =>"),f(v({code:r},e))},initManagerTemplate:K,initManager:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await K(n);return p("arguments",t.length,1,"initManager =>"),p("signers",a.length,1,"initManager =>"),f(v({code:r},e))},mintTokensTemplate:z,mintTokens:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await z(n);return p("arguments",t.length,2,"mintTokens =>"),p("signers",a.length,1,"mintTokens =>"),f(v({code:r},e))},registerContractTemplate:Y,registerContract:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await Y(n);return p("arguments",t.length,2,"registerContract =>"),p("signers",a.length,1,"registerContract =>"),f(v({code:r},e))},scratchTemplate:W,scratch:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await W(n);return p("arguments",t.length,0,"scratch =>"),p("signers",a.length,1,"scratch =>"),f(v({code:r},e))},setBlockOffsetTemplate:J,setBlockOffset:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await J(n);return p("arguments",t.length,1,"setBlockOffset =>"),p("signers",a.length,1,"setBlockOffset =>"),f(v({code:r},e))},updateContractTemplate:X,updateContract:async e=>{const{addressMap:n,args:t=[],signers:a=[]}=e,r=await X(n);return p("arguments",t.length,3,"updateContract =>"),p("signers",a.length,1,"updateContract =>"),f(v({code:r},e))}};const{updateContractTemplate:ee,deployContractTemplate:ne}=Z,te=e=>Buffer.from(e,"utf8").toString("hex"),ae=async(...e)=>{const n=await(async e=>{let n,t,a,r,s;if(I(e[0])){const[o]=e,{name:c,to:i,addressMap:l,args:g,update:u}=o;if(!c)throw Error("'name' field is missing");n=c,t=i,r=g,a=l,s=u}else[n,t,a,r,s]=e;const o=await de();return{name:n,to:t,args:r,update:s,addressMap:v({},xe,{FlowManager:o},a)}})(e),{to:t,name:a,addressMap:r,args:s,update:o=!1}=n,c=t||await de(),i=await ve({name:a,addressMap:r});return re({to:c,code:i,name:a,args:s,update:o})},re=async e=>{const{to:n,code:t,name:a,args:r,update:s}=e,o=n||await de(),c=await de(),i=te(t),l={FlowManager:c};let g=s?await ee(l):await ne(l),u=[a,i,c];const d=await m(t);if(r){u=u.concat(r);const e=w(d.args).map(e=>h(e)[0]),n="abcdefghijklmnopqrstuvwxyz";let t=[];for(let a=0;a<e.length;a++)t.push(`${n[a]}: ${e[a]}`);g=g.replace("##ARGS-WITH-TYPES##",`, ${d.args}`),g=g.replace("##ARGS-LIST##",t)}else g=g.replace("##ARGS-WITH-TYPES##",""),g=g.replace("##ARGS-LIST##","");return U({code:g,args:u,signers:[o]})},se='\n  pub contract FlowManager {\n\n    /// Account Manager\n    pub event AccountAdded(address: Address)\n\n    pub struct Mapper {\n        pub let accounts: {String: Address}\n\n        pub fun getAddress(_ name: String): Address? {\n            return self.accounts[name]\n        }\n\n        pub fun setAddress(_ name: String, address: Address){\n            self.accounts[name] = address\n            emit FlowManager.AccountAdded(address: address)\n        }\n\n        init(){\n            self.accounts = {}\n        }\n    }\n\n    pub fun getAccountAddress(_ name: String): Address?{\n        let accountManager = self.account\n            .getCapability(self.accountManagerPath)\n            .borrow<&FlowManager.Mapper>()!\n\n        return accountManager.getAddress(name)\n    }\n\n    pub let defaultAccounts: {Address : String}\n\n    pub fun resolveDefaultAccounts(_ address: Address): Address{\n        let alias = self.defaultAccounts[address]!\n        return self.getAccountAddress(alias)!\n    }\n\n    pub let accountManagerStorage: StoragePath\n    pub let contractManagerStorage: StoragePath\n    pub let accountManagerPath: PublicPath\n    pub let contractManagerPath: PublicPath\n\n    /// Environment Manager\n    pub event BlockOffsetChanged(offset: UInt64)\n\n    pub struct MockBlock {\n        pub let id: [UInt8; 32]\n        pub let height: UInt64\n        pub let view: UInt64\n        pub let timestamp: UFix64\n\n        init(_ id: [UInt8; 32], _ height: UInt64, _ view: UInt64, _ timestamp: UFix64){\n            self.id = id\n            self.height = height\n            self.view = view\n            self.timestamp = timestamp\n        }\n    }\n\n    pub fun setBlockOffset(_ offset: UInt64){\n        self.blockOffset = offset\n        emit FlowManager.BlockOffsetChanged(offset: offset)\n    }\n\n    pub fun getBlockHeight(): UInt64 {\n        var block = getCurrentBlock()\n        return block.height + self.blockOffset\n    }\n\n    pub fun getBlock(): MockBlock {\n        var block =  getCurrentBlock()\n        let mockBlock = MockBlock(block.id, block.height, block.view, block.timestamp);\n        return mockBlock\n    }\n\n    pub var blockOffset: UInt64;\n\n\n    // Initialize contract\n    init(){\n        // Environment defaults\n        self.blockOffset = 0;\n\n        // Account Manager initialization\n        let accountManager = Mapper()\n        let contractManager = Mapper()\n\n        self.defaultAccounts = {\n          0x01: "Alice",\n          0x02: "Bob",\n          0x03: "Charlie",\n          0x04: "Dave",\n          0x05: "Eve"\n        }\n\n        self.accountManagerStorage = /storage/testSuitAccountManager\n        self.contractManagerStorage = /storage/testSuitContractManager\n\n        self.accountManagerPath = /public/testSuitAccountManager\n        self.contractManagerPath = /public/testSuitContractManager\n        \n        // Destroy previously stored values\n        self.account.load<Mapper>(from: self.accountManagerStorage)\n        self.account.load<Mapper>(from: self.contractManagerStorage)\n\n        self.account.save(accountManager, to: self.accountManagerStorage)\n        self.account.save(contractManager, to: self.contractManagerStorage)\n\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\n    }\n}\n \n',oe="\n  import FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty, cause script will throw error if FlowManager is not\n    // added to service address\n}\n\n",ce="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.accountManagerPath\n    let accountManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return accountManager.getAddress(name)\n\n}\n",ie='\n  // This script reads the balance field of an account\'s FlowToken Balance\n\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\npub fun main(account: Address): UFix64 {\n    let acct = getAccount(account)\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\n        ?? panic("Could not borrow Balance reference to the Vault")\n\n    return vaultRef.balance\n}\n',le="\n  import FlowManager from 0x01\n\npub fun main():UInt64 {\n    return FlowManager.blockOffset\n}\n\n",ge="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.contractManagerPath\n    let contractManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return contractManager.getAddress(name)\n\n}\n";var ue=Z;const de=async()=>E(await n().get("SERVICE_ADDRESS")),pe=async()=>{const e={FlowManager:await de()},n=await(async(e={})=>{const n=v({},await g(),e);return u(oe,n,"checkManager =>"),d(oe,n)})(e);let[t,a]=await $({code:n,service:!0});return a&&null===t&&await(async()=>{const e=await ue.initManagerTemplate(),n=await(async(e={})=>{const n=v({},await g(),e);return u(se,n,"FlowManager =>"),d(se,n)})(),t=[te(n)];await U({code:e,args:t,service:!0})})(),de()},fe=async()=>{const e=await pe(),n=await(async(e={})=>{const n=v({},await g(),e);return u(le,n,"getBlockOffset =>"),d(le,n)})({FlowManager:e});return $({code:n})},me=async e=>{const n=await pe(),t=[e],a=await ue.setBlockOffsetTemplate({FlowManager:n});return U({code:a,args:t,payer:[n]})},we=async(e,n=!1)=>{if(n){const n=xe[e];if(void 0!==n)return n}const t=await pe(),a={FlowManager:t},r=await(async(e={})=>{const n=v({},await g(),e);return u(ge,n,"getContractAddress =>"),d(ge,n)})(a),s=[e,t],[o]=await $({code:r,args:s,service:!0});return o},he=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,Me=e=>e.split(/\s/).map(e=>e.replace(/\s/g,"")).filter(e=>e.length>0&&"import"!==e&&"from"!==e),Ae=(e,n)=>{const[t,a]=n;return e[t]=a,e},ye=e=>e&&0!==e.length?e.split("\n").filter(e=>e.includes("import")).map(Me).reduce(Ae,{}):{},be=(e,n,t=!0)=>e.replace(he,(e,a,r,s,o)=>{const c=t?r:o;return`${a}${r} from ${n instanceof Function?n(c):n[c]}`}),ke=async e=>{const n={},t=ye(e);for(const e in t)if(xe[e])n[e]=xe[e];else{const t=await we(e);n[e]=t}return n},xe={FlowToken:"0x0ae53cb6e3f42a79",FungibleToken:"0xee82856bf20e2aa6",FlowFees:"0xe5a8b7f23e8b548f",FlowStorageFees:"0xf8d6e0586b0a20c7"},Se={"0xe5a8b7f23e8b548f":"0xe5a8b7f23e8b548f","0xf8d6e0586b0a20c7":"0xf8d6e0586b0a20c7","0x0ae53cb6e3f42a79":"0x0ae53cb6e3f42a79","0xee82856bf20e2aa6":"0xee82856bf20e2aa6"},Fe=async(e,t="transactions")=>{const r=await n().get("BASE_PATH");let s=r;if(I(r)){const n=r[t];if(n)return a.resolve(n,`./${e}.cdc`);s=r.base}return a.resolve(s,`./${t}/${e}.cdc`)},Te=(e,n={},a=!1)=>{const r=(e=>t.readFileSync(e,"utf8"))(e);return n?be(r,v({},a?Se:xe,n)):r},ve=async({name:e,addressMap:n})=>{const t=await Fe(e,"contracts");return Te(t,n)},Pe=async({name:e,addressMap:n})=>{const t=await Fe(e,"transactions");return Te(t,n)},Ee=async({name:e,addressMap:n})=>{const t=await Fe(e,"scripts");return Te(t,n)},Be={ExampleToken:xe.FlowToken},Ce=e=>e[0].toLowerCase()+e.slice(1),Re=async e=>{const n=await(async e=>(await(async(e={})=>{const n=v({},await g(),e);return u(ie,n,"getBalance =>"),d(ie,n)})(Be)).replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:Ce(e)))("FlowToken"),t=be(n,xe);return $({code:t,args:[e]})},Ie=async(e,n)=>{const t=await(async e=>(await ue.mintTokensTemplate(Be)).replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:Ce(e)))("FlowToken"),a=be(t,xe);return U({code:a,args:[e,n]})},Oe=async e=>{const t=e||`deployment-account-${(Math.random()*Math.pow(10,8)).toFixed(0)}`,a=await pe(),r={FlowManager:a};let s;const o=await(async(e={})=>{const n=v({},await g(),e);return u(ce,n,"getAccountAddress =>"),d(ce,n)})(r),c=[t,a],[i]=await $({code:o,args:c,service:!0});if(s=i,null===s){const e=await ue.createAccountTemplate(r),o=[t,await(async()=>{const e=B.keyFromPrivate(Buffer.from(await n().get("PRIVATE_KEY"),"hex")).getPublic("hex").replace(/^04/,"");return k.encode([Buffer.from(e,"hex"),2,3,1e3]).toString("hex")})(),a],[c]=await U({code:e,args:o}),{events:i}=c;s=i.find(e=>e.type.includes("AccountAdded")).data.address}return s},{expect:Ue}=global,$e=async e=>"function"==typeof e?await e():await e,_e=async e=>{const n=$e(e);let t,a,r=await n;if(Array.isArray(r)){const{status:e,errorMessage:n}=r[0];t=e,a=n}else{const{status:e,errorMessage:n}=r;t=e,a=n}return await Ue(t).toBe(4),await Ue(a).toBe(""),$e(e)},De=async e=>$e(e),Le=async e=>{const n=$e(e);let t;try{const[e,a]=await n;t=a,await Ue(e).toBe(null)}catch(e){t="ERROR!"}await Ue(t).not.toBe(null)},He=async e=>{const n=$e(e);let t;try{const[e,a]=await n;t=a,await Ue(e).toBe(null)}catch(e){t="ERROR!",await Ue(n).rejects.toThrow()}await Ue(t).not.toBe(null)},Ge=async e=>{let n=e;return((e,n)=>new RegExp("import\\s+FlowManager").test(n))(0,e)||(n=`\n      ${await(async()=>`import FlowManager from ${await de()}`)()}\n      ${e}  \n  `),n.replace(/getCurrentBlock\(\).height/g,"FlowManager.getBlockHeight()")},{spawn:Ke}=require("child_process");var Ve=new class{constructor(){this.initialized=!1,this.logging=!1,this.logProcessor=e=>e}setLogging(e){this.logging=e}log(e,n="log"){this.logging&&console[n](e)}extractKeyValue(e){const[n,t]=e.split("=");return t.includes("LOG")?{key:n,value:t.replace('"[1;34m','"[1[34m')}:{key:n,value:t}}parseDataBuffer(e){const n=e.toString().match(/((\w+=\w+)|(\w+=".*?"))/g);return n?n.map(e=>e.replace(/"/g,"")).reduce((e,n)=>{const{key:t,value:a}=this.extractKeyValue(n);return e[t]=a,e},{}):{}}async start(e=8080,n=!1){let t=e-8080+3569;return this.logging=n,this.filters=[],this.process=Ke("flow",["emulator","-v","--http-port",e,"--port",t]),this.logProcessor=e=>e,new Promise((e,n)=>{let t;t=setInterval(async function(){try{await s(o([c(!1)])).then(i),console.log("Flow emulator is ready"),clearInterval(t),this.initialized=!0,e(!0)}catch(e){console.log("Flow emulator not ready yet")}},100),this.process.stdout.on("data",e=>{if(this.filters.length>0){for(let n=0;n<this.filters.length;n++)if(e.includes(`${this.filters[n]}`)){this.log(`LOG: ${e}`);break}}else this.log(`LOG: ${e}`);e.includes("Starting HTTP server")&&this.log("EMULATOR IS UP! Listening for events!")}),this.process.stderr.on("data",e=>{this.log(`ERROR: ${e}`,"error"),this.initialized=!1,clearInterval(t),n()}),this.process.on("close",n=>{this.log(`emulator exited with code ${n}`),this.initialized=!1,clearInterval(t),e(!1)})})}clearFilters(){this.filters=[]}removeFilter(e){this.filters=this.filters(n=>n!==e)}addFilter(e){this.filters.includes(e)||this.filters.push(e)}async stop(){return new Promise(e=>{this.process.kill(),setTimeout(()=>{this.initialized=!1,e(!1)},50)})}};export{Ge as builtInMethods,re as deployContract,ae as deployContractByName,Ve as emulator,$ as executeScript,ye as extractImports,Oe as getAccountAddress,fe as getBlockOffset,F as getConfigValue,we as getContractAddress,ve as getContractCode,Re as getFlowBalance,Ee as getScriptCode,de as getServiceAddress,Te as getTemplate,Pe as getTransactionCode,T as init,Ie as mintFlow,$e as promise,be as replaceImportAddresses,ke as resolveImports,U as sendTransaction,S as set,me as setBlockOffset,_e as shallPass,De as shallResolve,Le as shallRevert,He as shallThrow};
//# sourceMappingURL=index.modern.js.map
